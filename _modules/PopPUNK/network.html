<!doctype html>
<html class="no-js" lang="en" data-content_root="">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 7.1.2 and Furo 2023.09.10 -->
        <title>PopPUNK.network - PopPUNK 2.6.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">PopPUNK 2.6.2 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../_static/poppunk_v2.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">PopPUNK 2.6.2 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">PopPUNK documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sketching.html">Sketching (<code class="docutils literal notranslate"><span class="pre">--create-db</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qc.html">Data quality control (<code class="docutils literal notranslate"><span class="pre">--qc-db</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../model_fitting.html">Fitting new models (<code class="docutils literal notranslate"><span class="pre">--fit-model</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../model_distribution.html">Distributing PopPUNK models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../query_assignment.html">Query assignment (<code class="docutils literal notranslate"><span class="pre">poppunk_assign</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualisation.html">Creating visualisations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mst.html">Minimum spanning trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subclustering.html">Subclustering with PopPIPE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu.html">Using GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../poppunk_iterate.html">Iterative PopPUNK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">Citing PopPUNK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Reference documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../miscellaneous.html">Miscellaneous</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for PopPUNK.network</h1><div class="highlight"><pre>
<span></span><span class="c1"># vim: set fileencoding=&lt;utf-8&gt; :</span>
<span class="c1"># Copyright 2018-2023 John Lees and Nick Croucher</span>

<span class="sd">&#39;&#39;&#39;Network functions&#39;&#39;&#39;</span>

<span class="c1"># universal</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c1"># additional</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">graph_tool.all</span> <span class="k">as</span> <span class="nn">gt</span>

<span class="c1"># Load GPU libraries</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cupyx</span>
    <span class="kn">import</span> <span class="nn">cugraph</span>
    <span class="kn">import</span> <span class="nn">cudf</span>
    <span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
    <span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
    <span class="kn">import</span> <span class="nn">rmm</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">import</span> <span class="nn">poppunk_refine</span>

<span class="kn">from</span> <span class="nn">.__main__</span> <span class="kn">import</span> <span class="n">accepted_weights_types</span>
<span class="kn">from</span> <span class="nn">.__main__</span> <span class="kn">import</span> <span class="n">betweenness_sample_default</span>

<span class="kn">from</span> <span class="nn">.sketchlib</span> <span class="kn">import</span> <span class="n">addRandom</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">iterDistRows</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">readIsolateTypeFromCsv</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">check_and_set_gpu</span>

<span class="kn">from</span> <span class="nn">.unwords</span> <span class="kn">import</span> <span class="n">gen_unword</span>

<div class="viewcode-block" id="fetchNetwork"><a class="viewcode-back" href="../../api.html#PopPUNK.network.fetchNetwork">[docs]</a><span class="k">def</span> <span class="nf">fetchNetwork</span><span class="p">(</span><span class="n">network_dir</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">refList</span><span class="p">,</span> <span class="n">ref_graph</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">core_only</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">accessory_only</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the network based on input options</span>

<span class="sd">       Returns the network as a graph-tool format graph, and sets</span>
<span class="sd">       the slope parameter of the passed model object.</span>

<span class="sd">       Args:</span>
<span class="sd">            network_dir (str)</span>
<span class="sd">                A network used to define clusters</span>
<span class="sd">            model (ClusterFit)</span>
<span class="sd">                A fitted model object</span>
<span class="sd">            refList (list)</span>
<span class="sd">                Names of references that should be in the network</span>
<span class="sd">            ref_graph (bool)</span>
<span class="sd">                Use ref only graph, if available</span>
<span class="sd">                [default = False]</span>
<span class="sd">            core_only (bool)</span>
<span class="sd">                Return the network created using only core distances</span>
<span class="sd">                [default = False]</span>
<span class="sd">            accessory_only (bool)</span>
<span class="sd">                Return the network created using only accessory distances</span>
<span class="sd">                [default = False]</span>
<span class="sd">            use_gpu (bool)</span>
<span class="sd">                Use cugraph library to load graph</span>

<span class="sd">       Returns:</span>
<span class="sd">            genomeNetwork (graph)</span>
<span class="sd">                The loaded network</span>
<span class="sd">            cluster_file (str)</span>
<span class="sd">                The CSV of cluster assignments corresponding to this network</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If a refined fit, may use just core or accessory distances</span>
    <span class="n">dir_prefix</span> <span class="o">=</span> <span class="n">network_dir</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">network_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">graph_suffix</span> <span class="o">=</span> <span class="s1">&#39;.csv.gz&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">graph_suffix</span> <span class="o">=</span> <span class="s1">&#39;.gt&#39;</span>

    <span class="k">if</span> <span class="n">core_only</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;refine&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_graph</span><span class="p">:</span>
            <span class="n">network_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_core.refs_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">network_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_core_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span>
        <span class="n">cluster_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_core_clusters.csv&#39;</span>
    <span class="k">elif</span> <span class="n">accessory_only</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;refine&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_graph</span><span class="p">:</span>
            <span class="n">network_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_accessory.refs_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">network_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_accessory_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span>
        <span class="n">cluster_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_accessory_clusters.csv&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_graph</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;.refs_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span><span class="p">):</span>
            <span class="n">network_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;.refs_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">network_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_graph&#39;</span> <span class="o">+</span> <span class="n">graph_suffix</span>
        <span class="n">cluster_file</span> <span class="o">=</span> <span class="n">dir_prefix</span> <span class="o">+</span> <span class="s1">&#39;_clusters.csv&#39;</span>
        <span class="k">if</span> <span class="n">core_only</span> <span class="ow">or</span> <span class="n">accessory_only</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Can only do --core or --accessory fits from &quot;</span>
                             <span class="s2">&quot;a refined fit. Using the combined distances.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Load network file</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Loading network from &quot;</span> <span class="o">+</span> <span class="n">network_file</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">genomeNetwork</span> <span class="o">=</span> <span class="n">load_network_file</span><span class="p">(</span><span class="n">network_file</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>

    <span class="c1"># Ensure all in dists are in final network</span>
    <span class="n">checkNetworkVertexCount</span><span class="p">(</span><span class="n">refList</span><span class="p">,</span> <span class="n">genomeNetwork</span><span class="p">,</span> <span class="n">use_gpu</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">genomeNetwork</span><span class="p">,</span> <span class="n">cluster_file</span></div>

<div class="viewcode-block" id="load_network_file"><a class="viewcode-back" href="../../api.html#PopPUNK.network.load_network_file">[docs]</a><span class="k">def</span> <span class="nf">load_network_file</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the network based on input options</span>

<span class="sd">       Returns the network as a graph-tool format graph, and sets</span>
<span class="sd">       the slope parameter of the passed model object.</span>

<span class="sd">       Args:</span>
<span class="sd">            fn (str)</span>
<span class="sd">                Network file name</span>
<span class="sd">            use_gpu (bool)</span>
<span class="sd">                Use cugraph library to load graph</span>

<span class="sd">       Returns:</span>
<span class="sd">            genomeNetwork (graph)</span>
<span class="sd">                The loaded network</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load the network from the specified file</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">compression</span> <span class="o">=</span> <span class="s1">&#39;gzip&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;src&#39;</span> <span class="ow">in</span> <span class="n">G_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">G_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;dst&#39;</span><span class="p">:</span> <span class="s1">&#39;destination&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">genomeNetwork</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">in</span> <span class="n">G_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">G_df</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">,</span><span class="s1">&#39;weights&#39;</span><span class="p">]]</span>
            <span class="n">genomeNetwork</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="n">renumber</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">genomeNetwork</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span><span class="n">renumber</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Network loaded: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">genomeNetwork</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot; samples</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">genomeNetwork</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">load_graph</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Network loaded: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">genomeNetwork</span><span class="o">.</span><span class="n">vertices</span><span class="p">())))</span> <span class="o">+</span> <span class="s2">&quot; samples</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">genomeNetwork</span></div>

<div class="viewcode-block" id="checkNetworkVertexCount"><a class="viewcode-back" href="../../api.html#PopPUNK.network.checkNetworkVertexCount">[docs]</a><span class="k">def</span> <span class="nf">checkNetworkVertexCount</span><span class="p">(</span><span class="n">seq_list</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">use_gpu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks the number of network vertices matches the number</span>
<span class="sd">    of sequence names.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq_list (list)</span>
<span class="sd">            The list of sequence names</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The network of sequences</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use cugraph for graph analyses</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vertex_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">get_vertex_list</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">))</span>
    <span class="n">networkMissing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_list</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">vertex_list</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">networkMissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;ERROR: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">networkMissing</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; samples are missing from the final network</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="getCliqueRefs"><a class="viewcode-back" href="../../api.html#PopPUNK.network.getCliqueRefs">[docs]</a><span class="k">def</span> <span class="nf">getCliqueRefs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">reference_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursively prune a network of its cliques. Returns one vertex from</span>
<span class="sd">    a clique at each stage</span>

<span class="sd">    Args:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The graph to get clique representatives from</span>
<span class="sd">        reference_indices (set)</span>
<span class="sd">            The unique list of vertices being kept, to add to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cliques</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">max_cliques</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Get the first clique, and see if it has any members already</span>
        <span class="c1"># contained in the vertex list</span>
        <span class="n">clique</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">cliques</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">clique</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">):</span>
            <span class="n">reference_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">clique</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Remove the clique, and prune the resulting subgraph (recursively)</span>
        <span class="n">subgraph</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="p">[</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clique</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">getCliqueRefs</span><span class="p">(</span><span class="n">subgraph</span><span class="p">,</span> <span class="n">reference_indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">reference_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">subgraph</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">reference_indices</span></div>

<div class="viewcode-block" id="cliquePrune"><a class="viewcode-back" href="../../api.html#PopPUNK.network.cliquePrune">[docs]</a><span class="k">def</span> <span class="nf">cliquePrune</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">reference_indices</span><span class="p">,</span> <span class="n">components_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper function around :func:`~getCliqueRefs` so it can be</span>
<span class="sd">       called by a multiprocessing pool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gt</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">():</span>
        <span class="n">gt</span><span class="o">.</span><span class="n">openmp_set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
    <span class="n">subgraph</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">components_list</span> <span class="o">==</span> <span class="n">component</span><span class="p">)</span>
    <span class="n">refs</span> <span class="o">=</span> <span class="n">reference_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">refs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">subgraph</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ref_list</span> <span class="o">=</span> <span class="n">refs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_list</span> <span class="o">=</span> <span class="n">getCliqueRefs</span><span class="p">(</span><span class="n">subgraph</span><span class="p">,</span> <span class="n">refs</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ref_list</span><span class="p">))</span></div>

<div class="viewcode-block" id="translate_network_indices"><a class="viewcode-back" href="../../api.html#PopPUNK.network.translate_network_indices">[docs]</a><span class="k">def</span> <span class="nf">translate_network_indices</span><span class="p">(</span><span class="n">G_ref_df</span><span class="p">,</span> <span class="n">reference_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function for ensuring an updated reference network retains</span>
<span class="sd">    numbering consistent with sample names</span>

<span class="sd">       Args:</span>
<span class="sd">           G_ref_df (cudf data frame)</span>
<span class="sd">               List of edges in reference network</span>
<span class="sd">           reference_indices (list)</span>
<span class="sd">               The ordered list of reference indices in the original network</span>

<span class="sd">       Returns:</span>
<span class="sd">           G_ref (cugraph network)</span>
<span class="sd">               Network of reference sequences</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Translate network indices to match name order</span>
    <span class="n">G_ref_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">reference_indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G_ref_df</span><span class="p">[</span><span class="s1">&#39;old_source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span><span class="o">.</span><span class="n">to_pylist</span><span class="p">()]</span>
    <span class="n">G_ref_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">reference_indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G_ref_df</span><span class="p">[</span><span class="s1">&#39;old_destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span><span class="o">.</span><span class="n">to_pylist</span><span class="p">()]</span>
    <span class="n">G_ref</span> <span class="o">=</span> <span class="n">add_self_loop</span><span class="p">(</span><span class="n">G_ref_df</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">G_ref</span><span class="p">)</span></div>

<div class="viewcode-block" id="extractReferences"><a class="viewcode-back" href="../../api.html#PopPUNK.network.extractReferences">[docs]</a><span class="k">def</span> <span class="nf">extractReferences</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">dbOrder</span><span class="p">,</span> <span class="n">outPrefix</span><span class="p">,</span> <span class="n">outSuffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">type_isolate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">existingRefs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract references for each cluster based on cliques</span>

<span class="sd">       Writes chosen references to file by calling :func:`~writeReferences`</span>

<span class="sd">       Args:</span>
<span class="sd">           G (graph)</span>
<span class="sd">               A network used to define clusters</span>
<span class="sd">           dbOrder (list)</span>
<span class="sd">               The order of files in the sketches, so returned references are in the same order</span>
<span class="sd">           outPrefix (str)</span>
<span class="sd">               Prefix for output file</span>
<span class="sd">           outSuffix (str)</span>
<span class="sd">               Suffix for output file  (.refs will be appended)</span>
<span class="sd">           type_isolate (str)</span>
<span class="sd">               Isolate to be included in set of references</span>
<span class="sd">           existingRefs (list)</span>
<span class="sd">               References that should be used for each clique</span>
<span class="sd">           use_gpu (bool)</span>
<span class="sd">               Use cugraph for graph analysis (default = False)</span>

<span class="sd">       Returns:</span>
<span class="sd">           refFileName (str)</span>
<span class="sd">               The name of the file references were written to</span>
<span class="sd">           references (list)</span>
<span class="sd">               An updated list of the reference names</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">existingRefs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">reference_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">existingRefs</span><span class="p">)</span>
        <span class="n">index_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dbOrder</span><span class="p">)}</span>
        <span class="n">reference_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">index_lookup</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">references</span><span class="p">])</span>
    <span class="c1"># Add type isolate, if necessary</span>
    <span class="n">type_isolate_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">type_isolate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">type_isolate</span> <span class="ow">in</span> <span class="n">dbOrder</span><span class="p">:</span>
            <span class="n">type_isolate_index</span> <span class="o">=</span> <span class="n">dbOrder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">type_isolate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Type isolate &#39;</span> <span class="o">+</span> <span class="n">type_isolate</span> <span class="o">+</span> <span class="s1">&#39; not found</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>

        <span class="c1"># For large network, use more approximate method for extracting references</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Record the original components to which sequences belonged</span>
        <span class="n">component_assignments</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="c1"># Leiden method has resolution parameter - higher values give greater precision</span>
        <span class="n">partition_assignments</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">leiden</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># group by partition, which becomes the first column, so retrieve second column</span>
        <span class="n">reference_index_df</span> <span class="o">=</span> <span class="n">partition_assignments</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;partition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">reference_indices</span> <span class="o">=</span> <span class="n">reference_index_df</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span><span class="o">.</span><span class="n">to_pylist</span><span class="p">()</span>

        <span class="c1"># Add type isolate if necessary - before edges are added</span>
        <span class="k">if</span> <span class="n">type_isolate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">type_isolate_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference_indices</span><span class="p">:</span>
            <span class="n">reference_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_isolate_index</span><span class="p">)</span>

        <span class="c1"># Order found references as in sketchlib database</span>
        <span class="n">reference_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">dbOrder</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span>

        <span class="c1"># Extract reference edges</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">view_edge_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;src&#39;</span> <span class="ow">in</span> <span class="n">G_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">G_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="s1">&#39;old_source&#39;</span><span class="p">,</span><span class="s1">&#39;dst&#39;</span><span class="p">:</span> <span class="s1">&#39;old_destination&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;old_source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">:</span> <span class="s1">&#39;old_destination&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">G_ref_df</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;old_source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;old_destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span>
        <span class="c1"># Translate network indices to match name order</span>
        <span class="n">G_ref</span> <span class="o">=</span> <span class="n">translate_network_indices</span><span class="p">(</span><span class="n">G_ref_df</span><span class="p">,</span> <span class="n">reference_indices</span><span class="p">)</span>

        <span class="c1"># Check references in same component in overall graph are connected in the reference graph</span>
        <span class="c1"># First get components of original reference graph</span>
        <span class="n">reference_component_assignments</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G_ref</span><span class="p">)</span>
        <span class="n">reference_component_assignments</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="s1">&#39;ref_labels&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Merge with component assignments from overall graph</span>
        <span class="n">combined_vertex_assignments</span> <span class="o">=</span> <span class="n">reference_component_assignments</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">component_assignments</span><span class="p">,</span>
                                                                            <span class="n">on</span> <span class="o">=</span> <span class="s1">&#39;vertex&#39;</span><span class="p">,</span>
                                                                            <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="n">combined_vertex_assignments</span> <span class="o">=</span> <span class="n">combined_vertex_assignments</span><span class="p">[</span><span class="n">combined_vertex_assignments</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span>
        <span class="c1"># Find the number of components in the reference graph associated with each component in the overall graph -</span>
        <span class="c1"># should be one if there is a one-to-one mapping of components - else links need to be added</span>
        <span class="n">max_ref_comp_count</span> <span class="o">=</span> <span class="n">combined_vertex_assignments</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="n">sort</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="s1">&#39;ref_labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_ref_comp_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Iterate through components</span>
            <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">component_df</span> <span class="ow">in</span> <span class="n">combined_vertex_assignments</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="n">sort</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
                <span class="c1"># Find components in the overall graph matching multiple components in the reference graph</span>
                <span class="k">if</span> <span class="n">component_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="n">sort</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="s1">&#39;ref_labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Make a graph of the component from the overall graph</span>
                    <span class="n">vertices_in_component</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="p">[</span><span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">component</span><span class="p">][</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span>
                    <span class="n">references_in_component</span> <span class="o">=</span> <span class="n">vertices_in_component</span><span class="p">[</span><span class="n">vertices_in_component</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">G_component_df</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">vertices_in_component</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">vertices_in_component</span><span class="p">)]</span>
                    <span class="n">G_component</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
                    <span class="n">G_component</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">G_component_df</span><span class="p">)</span>
                    <span class="c1"># Find single shortest path from a reference to all other nodes in the component</span>
                    <span class="n">traversal</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">traversal</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">G_component</span><span class="p">,</span><span class="n">source</span> <span class="o">=</span> <span class="n">references_in_component</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">reference_index_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)</span>
                    <span class="c1"># Add predecessors to reference sequences on the SSSPs</span>
                    <span class="n">predecessor_list</span> <span class="o">=</span> <span class="n">traversal</span><span class="p">[</span><span class="n">traversal</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)][</span><span class="s1">&#39;predecessor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">predecessors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">predecessor_list</span><span class="p">[</span><span class="n">predecessor_list</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="c1"># Add predecessors to reference set and check whether this results in complete paths</span>
                    <span class="c1"># where complete paths are indicated by references&#39; predecessors being within the set of</span>
                    <span class="c1"># references</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span> <span class="o">-</span> <span class="n">reference_index_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">reference_index_set</span> <span class="o">=</span> <span class="n">reference_index_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span>
                        <span class="n">predecessor_list</span> <span class="o">=</span> <span class="n">traversal</span><span class="p">[</span><span class="n">traversal</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)][</span><span class="s1">&#39;predecessor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                        <span class="n">predecessors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">predecessor_list</span><span class="p">[</span><span class="n">predecessor_list</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="c1"># Add expanded reference set to the overall list</span>
                    <span class="n">reference_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reference_index_set</span><span class="p">)</span>
            <span class="c1"># Create new reference graph</span>
            <span class="n">G_ref_df</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;old_source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;old_destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span>
            <span class="n">G_ref</span> <span class="o">=</span> <span class="n">translate_network_indices</span><span class="p">(</span><span class="n">G_ref_df</span><span class="p">,</span> <span class="n">reference_indices</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Each component is independent, so can be multithreaded</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_components</span><span class="p">(</span><span class="n">G</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>

        <span class="c1"># Turn gt threading off and on again either side of the parallel loop</span>
        <span class="k">if</span> <span class="n">gt</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">():</span>
            <span class="n">gt</span><span class="o">.</span><span class="n">openmp_set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Cliques are pruned, taking one reference from each, until none remain</span>
        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">ref_lists</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">cliquePrune</span><span class="p">,</span>
                                            <span class="n">graph</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
                                            <span class="n">reference_indices</span><span class="o">=</span><span class="n">reference_indices</span><span class="p">,</span>
                                            <span class="n">components_list</span><span class="o">=</span><span class="n">components</span><span class="p">),</span>
                                 <span class="nb">set</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
        <span class="c1"># Returns nested lists, which need to be flattened</span>
        <span class="n">reference_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">entry</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">ref_lists</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>

        <span class="c1"># Add type isolate if necessary - before edges are added</span>
        <span class="k">if</span> <span class="n">type_isolate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">type_isolate_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference_indices</span><span class="p">:</span>
            <span class="n">reference_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">type_isolate_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gt</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">():</span>
            <span class="n">gt</span><span class="o">.</span><span class="n">openmp_set_num_threads</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span>

        <span class="c1"># Use a vertex filter to extract the subgraph of refences</span>
        <span class="c1"># as a graphview</span>
        <span class="n">reference_vertex</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">reference_indices</span><span class="p">:</span>
                <span class="n">reference_vertex</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reference_vertex</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">G_ref</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vfilt</span> <span class="o">=</span> <span class="n">reference_vertex</span><span class="p">)</span>
        <span class="n">G_ref</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G_ref</span><span class="p">,</span> <span class="n">prune</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># https://stackoverflow.com/questions/30839929/graph-tool-graphview-object</span>

        <span class="c1"># Find any clusters which are represented by &gt;1 references</span>
        <span class="c1"># This creates a dictionary: cluster_id: set(ref_idx in cluster)</span>
        <span class="n">clusters_in_full_graph</span> <span class="o">=</span> <span class="n">printClusters</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">dbOrder</span><span class="p">,</span> <span class="n">printCSV</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">reference_clusters_in_full_graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reference_index</span> <span class="ow">in</span> <span class="n">reference_indices</span><span class="p">:</span>
            <span class="n">reference_clusters_in_full_graph</span><span class="p">[</span><span class="n">clusters_in_full_graph</span><span class="p">[</span><span class="n">dbOrder</span><span class="p">[</span><span class="n">reference_index</span><span class="p">]]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reference_index</span><span class="p">)</span>

        <span class="c1"># Calculate the component membership within the reference graph</span>
        <span class="n">ref_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dbOrder</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span>
        <span class="n">clusters_in_reference_graph</span> <span class="o">=</span> <span class="n">printClusters</span><span class="p">(</span><span class="n">G_ref</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">printCSV</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Record the components/clusters the references are in the reference graph</span>
        <span class="c1"># dict: name: ref_cluster</span>
        <span class="n">reference_clusters_in_reference_graph</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">reference_name</span> <span class="ow">in</span> <span class="n">ref_order</span><span class="p">:</span>
            <span class="n">reference_clusters_in_reference_graph</span><span class="p">[</span><span class="n">reference_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusters_in_reference_graph</span><span class="p">[</span><span class="n">reference_name</span><span class="p">]</span>

        <span class="c1"># Check if multi-reference components have been split as a validation test</span>
        <span class="c1"># First iterate through clusters</span>
        <span class="n">network_update_required</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">ref_idxs</span> <span class="ow">in</span> <span class="n">reference_clusters_in_full_graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Identify multi-reference clusters by this length</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ref_idxs</span><span class="p">)</span>
                <span class="c1"># check if these are still in the same component in the reference graph</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">check</span><span class="p">)):</span>
                    <span class="n">component_i</span> <span class="o">=</span> <span class="n">reference_clusters_in_reference_graph</span><span class="p">[</span><span class="n">dbOrder</span><span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">check</span><span class="p">)):</span>
                        <span class="c1"># Add intermediate nodes</span>
                        <span class="n">component_j</span> <span class="o">=</span> <span class="n">reference_clusters_in_reference_graph</span><span class="p">[</span><span class="n">dbOrder</span><span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
                        <span class="k">if</span> <span class="n">component_i</span> <span class="o">!=</span> <span class="n">component_j</span><span class="p">:</span>
                            <span class="n">network_update_required</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">vertex_list</span><span class="p">,</span> <span class="n">edge_list</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">check</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="c1"># update reference list</span>
                            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertex_list</span><span class="p">:</span>
                                <span class="n">reference_vertex</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">reference_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>

        <span class="c1"># update reference graph if vertices have been added</span>
        <span class="k">if</span> <span class="n">network_update_required</span><span class="p">:</span>
            <span class="n">G_ref</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vfilt</span> <span class="o">=</span> <span class="n">reference_vertex</span><span class="p">)</span>
            <span class="n">G_ref</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G_ref</span><span class="p">,</span> <span class="n">prune</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># https://stackoverflow.com/questions/30839929/graph-tool-graphview-object</span>

    <span class="c1"># Order found references as in sketch files</span>
    <span class="n">reference_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">dbOrder</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">reference_indices</span><span class="p">)]</span>
    <span class="n">refFileName</span> <span class="o">=</span> <span class="n">writeReferences</span><span class="p">(</span><span class="n">reference_names</span><span class="p">,</span> <span class="n">outPrefix</span><span class="p">,</span> <span class="n">outSuffix</span> <span class="o">=</span> <span class="n">outSuffix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reference_indices</span><span class="p">,</span> <span class="n">reference_names</span><span class="p">,</span> <span class="n">refFileName</span><span class="p">,</span> <span class="n">G_ref</span></div>

<div class="viewcode-block" id="writeReferences"><a class="viewcode-back" href="../../api.html#PopPUNK.network.writeReferences">[docs]</a><span class="k">def</span> <span class="nf">writeReferences</span><span class="p">(</span><span class="n">refList</span><span class="p">,</span> <span class="n">outPrefix</span><span class="p">,</span> <span class="n">outSuffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Writes chosen references to file</span>

<span class="sd">    Args:</span>
<span class="sd">        refList (list)</span>
<span class="sd">            Reference names to write</span>
<span class="sd">        outPrefix (str)</span>
<span class="sd">            Prefix for output file</span>
<span class="sd">        outSuffix (str)</span>
<span class="sd">            Suffix for output file (.refs will be appended)</span>

<span class="sd">    Returns:</span>
<span class="sd">        refFileName (str)</span>
<span class="sd">            The name of the file references were written to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># write references to file</span>
    <span class="n">refFileName</span> <span class="o">=</span> <span class="n">outPrefix</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">outPrefix</span><span class="p">)</span> <span class="o">+</span> <span class="n">outSuffix</span> <span class="o">+</span> <span class="s2">&quot;.refs&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">refFileName</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">rFile</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">refList</span><span class="p">:</span>
            <span class="n">rFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">refFileName</span></div>

<div class="viewcode-block" id="network_to_edges"><a class="viewcode-back" href="../../api.html#PopPUNK.network.network_to_edges">[docs]</a><span class="k">def</span> <span class="nf">network_to_edges</span><span class="p">(</span><span class="n">prev_G_fn</span><span class="p">,</span> <span class="n">rlist</span><span class="p">,</span> <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">old_ids</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">previous_pkl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load previous network, extract the edges to match the</span>
<span class="sd">    vertex order specified in rlist, and also return weights if specified.</span>

<span class="sd">    Args:</span>
<span class="sd">        prev_G_fn (str or graph object)</span>
<span class="sd">            Path of file containing existing network, or already-loaded</span>
<span class="sd">            graph object</span>
<span class="sd">        adding_qq_dists (bool)</span>
<span class="sd">            Boolean specifying whether query-query edges are being added</span>
<span class="sd">            to an existing network, such that not all the sequence IDs will</span>
<span class="sd">            be found in the old IDs, which should already be correctly ordered</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            List of reference sequence labels in new network</span>
<span class="sd">        old_ids (list)</span>
<span class="sd">            List of IDs of vertices in existing network</span>
<span class="sd">        previous_pkl (str)</span>
<span class="sd">            Path of pkl file containing names of sequences in</span>
<span class="sd">            previous network</span>
<span class="sd">        weights (bool)</span>
<span class="sd">            Whether to return edge weights</span>
<span class="sd">            (default = False)</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use cugraph for graph analyses</span>

<span class="sd">    Returns:</span>
<span class="sd">        source_ids (list)</span>
<span class="sd">            Source nodes for each edge</span>
<span class="sd">        target_ids (list)</span>
<span class="sd">            Target nodes for each edge</span>
<span class="sd">        edge_weights (list)</span>
<span class="sd">            Weights for each new edge</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load graph from file if passed string; else use graph object passed in</span>
    <span class="c1"># as argument</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prev_G_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">prev_G</span> <span class="o">=</span> <span class="n">load_network_file</span><span class="p">(</span><span class="n">prev_G_fn</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prev_G</span> <span class="o">=</span> <span class="n">prev_G_fn</span>

    <span class="c1"># load list of names in previous network if pkl name supplied</span>
    <span class="k">if</span> <span class="n">previous_pkl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">previous_pkl</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickle_file</span><span class="p">:</span>
            <span class="n">old_rlist</span><span class="p">,</span> <span class="n">old_qlist</span><span class="p">,</span> <span class="bp">self</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pickle_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_rlist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_rlist</span> <span class="o">+</span> <span class="n">old_qlist</span>
    <span class="k">elif</span> <span class="n">old_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Missing .pkl file containing names of sequences in &#39;</span>
                         <span class="s1">&#39;previous network</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get edges as lists of source,destination,weight using original IDs</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">prev_G</span><span class="o">.</span><span class="n">view_edge_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Loaded network does not have edge weights; try a different &#39;</span>
                                    <span class="s1">&#39;network or turn off graph weights</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;src&#39;</span> <span class="ow">in</span> <span class="n">G_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">G_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;src&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">:</span> <span class="s1">&#39;dst&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span><span class="o">.</span><span class="n">to_pylist</span><span class="p">()</span>
        <span class="n">G_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;dst&#39;</span><span class="p">:</span> <span class="s1">&#39;destination&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">old_source_ids</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span><span class="o">.</span><span class="n">to_pylist</span><span class="p">()</span>
        <span class="n">old_target_ids</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span><span class="o">.</span><span class="n">to_pylist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get the source and target nodes</span>
        <span class="n">old_source_ids</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">edge_endpoint_property</span><span class="p">(</span><span class="n">prev_G</span><span class="p">,</span> <span class="n">prev_G</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">)</span>
        <span class="n">old_target_ids</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">edge_endpoint_property</span><span class="p">(</span><span class="n">prev_G</span><span class="p">,</span> <span class="n">prev_G</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">)</span>
        <span class="c1"># get the weights</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev_G</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prev_G</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Loaded network does not have edge weights; try a different &#39;</span>
                                    <span class="s1">&#39;network or turn off graph weights</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">edge_weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">prev_G</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span>

    <span class="c1"># If appending queries to an existing network, then the recovered links can be left</span>
    <span class="c1"># unchanged, as the new IDs are the queries, and the existing sequences will not be found</span>
    <span class="c1"># in the list of IDs</span>
    <span class="k">if</span> <span class="n">adding_qq_dists</span><span class="p">:</span>
        <span class="n">source_ids</span> <span class="o">=</span> <span class="n">old_source_ids</span>
        <span class="n">target_ids</span> <span class="o">=</span> <span class="n">old_target_ids</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Update IDs to new versions</span>
            <span class="n">old_id_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">rlist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">old_ids</span><span class="p">]</span>
            <span class="c1"># translate to indices</span>
            <span class="n">source_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_id_indices</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">old_source_ids</span><span class="p">]</span>
            <span class="n">target_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_id_indices</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">old_target_ids</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Network size mismatch. Previous network nodes: </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">old_id_indices</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;New network nodes: </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">old_source_ids</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">old_target_ids</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># return values</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">source_ids</span><span class="p">,</span> <span class="n">target_ids</span><span class="p">,</span> <span class="n">edge_weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">source_ids</span><span class="p">,</span> <span class="n">target_ids</span></div>

<div class="viewcode-block" id="print_network_summary"><a class="viewcode-back" href="../../api.html#PopPUNK.network.print_network_summary">[docs]</a><span class="k">def</span> <span class="nf">print_network_summary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample_default</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper function for printing network information</span>

<span class="sd">    Args:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            List of reference sequence labels</span>
<span class="sd">        betweenness_sample (int)</span>
<span class="sd">            Number of sequences per component used to estimate betweenness using</span>
<span class="sd">            a GPU. Smaller numbers are faster but less precise [default = 100]</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print some summaries</span>
    <span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span> <span class="o">=</span> <span class="n">networkSummary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Network summary:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Components</span><span class="se">\t\t\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Density</span><span class="se">\t\t\t\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Transitivity</span><span class="se">\t\t\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Mean betweenness</span><span class="se">\t\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Weighted-mean betweenness</span><span class="se">\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Score</span><span class="se">\t\t\t\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Score (w/ betweenness)</span><span class="se">\t\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                   <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Score (w/ weighted-betweenness)</span><span class="se">\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
                                                   <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_weights"><a class="viewcode-back" href="../../api.html#PopPUNK.network.process_weights">[docs]</a><span class="k">def</span> <span class="nf">process_weights</span><span class="p">(</span><span class="n">distMat</span><span class="p">,</span> <span class="n">weights_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate edge weights from the distance matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        distMat (2 column ndarray)</span>
<span class="sd">            Numpy array of pairwise distances</span>
<span class="sd">        weights_type (str)</span>
<span class="sd">            Measure to calculate from the distMat to use as edge weights in network</span>
<span class="sd">            - options are core, accessory or euclidean distance</span>

<span class="sd">    Returns:</span>
<span class="sd">        processed_weights (list)</span>
<span class="sd">            Edge weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">weights_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">distMat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check weights type is valid</span>
        <span class="k">if</span> <span class="n">weights_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_weights_types</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Unable to calculate distance type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">weights_type</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;; &quot;</span>
                             <span class="s2">&quot;accepted types are &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">accepted_weights_types</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights_type</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">:</span>
            <span class="n">processed_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">distMat</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">weights_type</span> <span class="o">==</span> <span class="s1">&#39;core&#39;</span><span class="p">:</span>
            <span class="n">processed_weights</span> <span class="o">=</span> <span class="n">distMat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">weights_type</span> <span class="o">==</span> <span class="s1">&#39;accessory&#39;</span><span class="p">:</span>
            <span class="n">processed_weights</span> <span class="o">=</span> <span class="n">distMat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Require distance matrix to calculate distances</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">processed_weights</span></div>

<div class="viewcode-block" id="process_previous_network"><a class="viewcode-back" href="../../api.html#PopPUNK.network.process_previous_network">[docs]</a><span class="k">def</span> <span class="nf">process_previous_network</span><span class="p">(</span><span class="n">previous_network</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">old_ids</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">previous_pkl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">vertex_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract edge types from an existing network</span>

<span class="sd">    Args:</span>
<span class="sd">        previous_network (str or graph object)</span>
<span class="sd">            Name of file containing a previous network to be integrated into this new</span>
<span class="sd">            network, or already-loaded graph object</span>
<span class="sd">        adding_qq_dists (bool)</span>
<span class="sd">            Boolean specifying whether query-query edges are being added</span>
<span class="sd">            to an existing network, such that not all the sequence IDs will</span>
<span class="sd">            be found in the old IDs, which should already be correctly ordered</span>
<span class="sd">        old_ids (list)</span>
<span class="sd">            Ordered list of vertex names in previous network</span>
<span class="sd">        previous_pkl (str)</span>
<span class="sd">            Name of file containing the names of the sequences in the previous_network</span>
<span class="sd">            ordered based on the original network construction</span>
<span class="sd">        vertex_labels (list)</span>
<span class="sd">            Ordered list of sequence labels</span>
<span class="sd">        weights (bool)</span>
<span class="sd">            Whether weights should be extracted from the previous network</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>

<span class="sd">    Returns:</span>
<span class="sd">        extra_sources (list)</span>
<span class="sd">            List of source node identifiers</span>
<span class="sd">        extra_targets (list)</span>
<span class="sd">            List of destination node identifiers</span>
<span class="sd">        extra_weights (list or None)</span>
<span class="sd">            List of edge weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">previous_pkl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">old_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="c1"># Extract from network</span>
            <span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span><span class="p">,</span> <span class="n">extra_weights</span> <span class="o">=</span> <span class="n">network_to_edges</span><span class="p">(</span><span class="n">previous_network</span><span class="p">,</span>
                                                                            <span class="n">vertex_labels</span><span class="p">,</span>
                                                                            <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="n">adding_qq_dists</span><span class="p">,</span>
                                                                            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                                                            <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                                                            <span class="n">weights</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract from network</span>
            <span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span> <span class="o">=</span> <span class="n">network_to_edges</span><span class="p">(</span><span class="n">previous_network</span><span class="p">,</span>
                                                            <span class="n">vertex_labels</span><span class="p">,</span>
                                                            <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="n">adding_qq_dists</span><span class="p">,</span>
                                                            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                                            <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                                            <span class="n">weights</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
            <span class="n">extra_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;A distance pkl corresponding to &#39;</span> <span class="o">+</span> <span class="n">previous_pkl</span> <span class="o">+</span> <span class="s1">&#39; is required for loading</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span><span class="p">,</span> <span class="n">extra_weights</span></div>

<div class="viewcode-block" id="construct_network_from_edge_list"><a class="viewcode-back" href="../../api.html#PopPUNK.network.construct_network_from_edge_list">[docs]</a><span class="k">def</span> <span class="nf">construct_network_from_edge_list</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span>
                                        <span class="n">qlist</span><span class="p">,</span>
                                        <span class="n">edge_list</span><span class="p">,</span>
                                        <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">distMat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">previous_network</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">old_ids</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">previous_pkl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample_default</span><span class="p">,</span>
                                        <span class="n">summarise</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct an undirected network using a data frame of edges. Nodes are samples and</span>
<span class="sd">    edges where samples are within the same cluster</span>

<span class="sd">    Will print summary statistics about the network to ``STDERR``</span>

<span class="sd">    Args:</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            List of reference sequence labels</span>
<span class="sd">        qlist (list)</span>
<span class="sd">            List of query sequence labels</span>
<span class="sd">        G_df (cudf or pandas data frame)</span>
<span class="sd">            Data frame in which the first two columns are the nodes linked by edges</span>
<span class="sd">        weights (list)</span>
<span class="sd">            List of edge weights</span>
<span class="sd">        distMat (2 column ndarray)</span>
<span class="sd">            Numpy array of pairwise distances</span>
<span class="sd">        previous_network (str or graph object)</span>
<span class="sd">            Name of file containing a previous network to be integrated into this new</span>
<span class="sd">            network, or the already-loaded graph object</span>
<span class="sd">        adding_qq_dists (bool)</span>
<span class="sd">            Boolean specifying whether query-query edges are being added</span>
<span class="sd">            to an existing network, such that not all the sequence IDs will</span>
<span class="sd">            be found in the old IDs, which should already be correctly ordered</span>
<span class="sd">        old_ids (list)</span>
<span class="sd">            Ordered list of vertex names in previous network</span>
<span class="sd">        previous_pkl (str)</span>
<span class="sd">            Name of file containing the names of the sequences in the previous_network</span>
<span class="sd">        betweenness_sample (int)</span>
<span class="sd">            Number of sequences per component used to estimate betweenness using</span>
<span class="sd">            a GPU. Smaller numbers are faster but less precise [default = 100]</span>
<span class="sd">        summarise (bool)</span>
<span class="sd">            Whether to calculate and print network summaries with :func:`~networkSummary`</span>
<span class="sd">            (default = True)</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The resulting network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># data structures</span>
    <span class="k">if</span> <span class="n">rlist</span> <span class="o">!=</span> <span class="n">qlist</span><span class="p">:</span>
        <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">rlist</span> <span class="o">+</span> <span class="n">qlist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">rlist</span>

    <span class="c1"># Create new network</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="c1"># benchmarking concurs with https://stackoverflow.com/questions/55922162/recommended-cudf-dataframe-construction</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edge_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">edge_gpu_matrix</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">edge_array</span><span class="p">)</span>
            <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edge_gpu_matrix</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Cannot generate an array when one edge</span>
            <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">])</span>
            <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_df</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">G_df</span><span class="p">,</span>
                                        <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                                        <span class="n">distMat</span> <span class="o">=</span> <span class="n">distMat</span><span class="p">,</span>
                                        <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="n">adding_qq_dists</span><span class="p">,</span>
                                        <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                        <span class="n">previous_network</span> <span class="o">=</span> <span class="n">previous_network</span><span class="p">,</span>
                                        <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                        <span class="n">summarise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Load previous network</span>
        <span class="k">if</span> <span class="n">previous_network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span><span class="p">,</span> <span class="n">extra_weights</span> <span class="o">=</span> \
                <span class="n">process_previous_network</span><span class="p">(</span><span class="n">previous_network</span> <span class="o">=</span> <span class="n">previous_network</span><span class="p">,</span>
                                            <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="n">adding_qq_dists</span><span class="p">,</span>
                                            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                            <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                            <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">vertex_labels</span><span class="p">,</span>
                                            <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
        <span class="c1"># Construct list of tuples for graph-tool</span>
        <span class="c1"># Include information from previous graph if supplied</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weighted_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">),</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
                <span class="n">weighted_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">previous_network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span><span class="p">,</span> <span class="n">extra_weights</span><span class="p">):</span>
                    <span class="n">weighted_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">weighted_edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">previous_network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span><span class="p">):</span>
                    <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>

        <span class="c1"># build the graph (from scratch)</span>
        <span class="c1">#TODO append to existing graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">directed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eweight</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">eweight</span><span class="p">])</span>
            <span class="n">G</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eweight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">summarise</span><span class="p">:</span>
        <span class="n">print_network_summary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="construct_network_from_df"><a class="viewcode-back" href="../../api.html#PopPUNK.network.construct_network_from_df">[docs]</a><span class="k">def</span> <span class="nf">construct_network_from_df</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span>
                                <span class="n">qlist</span><span class="p">,</span>
                                <span class="n">G_df</span><span class="p">,</span>
                                <span class="n">weights</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">distMat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">previous_network</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">old_ids</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">previous_pkl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample_default</span><span class="p">,</span>
                                <span class="n">summarise</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct an undirected network using a data frame of edges. Nodes are samples and</span>
<span class="sd">    edges where samples are within the same cluster</span>

<span class="sd">    Will print summary statistics about the network to ``STDERR``</span>

<span class="sd">    Args:</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            List of reference sequence labels</span>
<span class="sd">        qlist (list)</span>
<span class="sd">            List of query sequence labels</span>
<span class="sd">        G_df (cudf or pandas data frame)</span>
<span class="sd">            Data frame in which the first two columns are the nodes linked by edges</span>
<span class="sd">        weights (bool)</span>
<span class="sd">            Whether weights in the G_df data frame should be included in the network</span>
<span class="sd">        distMat (2 column ndarray)</span>
<span class="sd">            Numpy array of pairwise distances</span>
<span class="sd">        previous_network (str or graph object)</span>
<span class="sd">            Name of file containing a previous network to be integrated into this new</span>
<span class="sd">            network, or the already-loaded graph object</span>
<span class="sd">        adding_qq_dists (bool)</span>
<span class="sd">            Boolean specifying whether query-query edges are being added</span>
<span class="sd">            to an existing network, such that not all the sequence IDs will</span>
<span class="sd">            be found in the old IDs, which should already be correctly ordered</span>
<span class="sd">        old_ids (list)</span>
<span class="sd">            Ordered list of vertex names in previous network</span>
<span class="sd">        previous_pkl (str)</span>
<span class="sd">            Name of file containing the names of the sequences in the previous_network</span>
<span class="sd">        betweenness_sample (int)</span>
<span class="sd">            Number of sequences per component used to estimate betweenness using</span>
<span class="sd">            a GPU. Smaller numbers are faster but less precise [default = 100]</span>
<span class="sd">        summarise (bool)</span>
<span class="sd">            Whether to calculate and print network summaries with :func:`~networkSummary`</span>
<span class="sd">            (default = True)</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The resulting network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># data structures</span>
    <span class="k">if</span> <span class="n">rlist</span> <span class="o">!=</span> <span class="n">qlist</span><span class="p">:</span>
        <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">rlist</span> <span class="o">+</span> <span class="n">qlist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">rlist</span>

    <span class="c1"># Check df format is correct</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">G_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">,</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span>

    <span class="c1"># Load previous network</span>
    <span class="k">if</span> <span class="n">previous_network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_sources</span><span class="p">,</span> <span class="n">extra_targets</span><span class="p">,</span> <span class="n">extra_weights</span> <span class="o">=</span> <span class="n">process_previous_network</span><span class="p">(</span><span class="n">previous_network</span> <span class="o">=</span> <span class="n">previous_network</span><span class="p">,</span>
                                                                                <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="n">adding_qq_dists</span><span class="p">,</span>
                                                                                <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                                                                <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                                                                <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">vertex_labels</span><span class="p">,</span>
                                                                                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">,</span>
                                                                                <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
            <span class="n">G_extra_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_extra_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">G_extra_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_sources</span>
        <span class="n">G_extra_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_targets</span>
        <span class="k">if</span> <span class="n">extra_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">G_extra_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_weights</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">G_df</span><span class="p">,</span><span class="n">G_extra_df</span><span class="p">],</span> <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="c1"># direct conversion</span>
        <span class="c1"># ensure the highest-integer node is included in the edge list</span>
        <span class="c1"># by adding a self-loop if necessary; see https://github.com/rapidsai/cugraph/issues/1206</span>
        <span class="n">max_in_vertex_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">use_weights</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">use_weights</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">add_self_loop</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">max_in_vertex_labels</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">use_weights</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Convert bool to list of weights or None</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Convert data frame to list of tuples</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">G_df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">G_df</span><span class="p">[[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">]]]))</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_edge_list</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">connections</span><span class="p">,</span>
                                            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">,</span>
                                            <span class="n">distMat</span> <span class="o">=</span> <span class="n">distMat</span><span class="p">,</span>
                                            <span class="n">previous_network</span> <span class="o">=</span> <span class="n">previous_network</span><span class="p">,</span>
                                            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                            <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                            <span class="n">summarise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">summarise</span><span class="p">:</span>
        <span class="n">print_network_summary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="construct_network_from_sparse_matrix"><a class="viewcode-back" href="../../api.html#PopPUNK.network.construct_network_from_sparse_matrix">[docs]</a><span class="k">def</span> <span class="nf">construct_network_from_sparse_matrix</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span>
                                            <span class="n">qlist</span><span class="p">,</span>
                                            <span class="n">sparse_input</span><span class="p">,</span>
                                            <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                            <span class="n">previous_network</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                            <span class="n">previous_pkl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                            <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample_default</span><span class="p">,</span>
                                            <span class="n">summarise</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct an undirected network using a sparse matrix. Nodes are samples and</span>
<span class="sd">    edges where samples are within the same cluster</span>

<span class="sd">    Will print summary statistics about the network to ``STDERR``</span>

<span class="sd">    Args:</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            List of reference sequence labels</span>
<span class="sd">        qlist (list)</span>
<span class="sd">            List of query sequence labels</span>
<span class="sd">        sparse_input (numpy.array)</span>
<span class="sd">            Sparse distance matrix from lineage fit</span>
<span class="sd">        weights (list)</span>
<span class="sd">            List of weights for each edge in the network</span>
<span class="sd">        distMat (2 column ndarray)</span>
<span class="sd">            Numpy array of pairwise distances</span>
<span class="sd">        previous_network (str)</span>
<span class="sd">            Name of file containing a previous network to be integrated into this new</span>
<span class="sd">            network</span>
<span class="sd">        previous_pkl (str)</span>
<span class="sd">            Name of file containing the names of the sequences in the previous_network</span>
<span class="sd">        betweenness_sample (int)</span>
<span class="sd">            Number of sequences per component used to estimate betweenness using</span>
<span class="sd">            a GPU. Smaller numbers are faster but less precise [default = 100]</span>
<span class="sd">        summarise (bool)</span>
<span class="sd">            Whether to calculate and print network summaries with :func:`~networkSummary`</span>
<span class="sd">            (default = True)</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The resulting network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_input</span><span class="o">.</span><span class="n">row</span>
    <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">sparse_input</span><span class="o">.</span><span class="n">col</span>
    <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_input</span><span class="o">.</span><span class="n">data</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_df</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">G_df</span><span class="p">,</span>
                                    <span class="n">weights</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">previous_network</span> <span class="o">=</span> <span class="n">previous_network</span><span class="p">,</span>
                                    <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                    <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span>
                                    <span class="n">summarise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">summarise</span><span class="p">:</span>
        <span class="n">print_network_summary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="construct_dense_weighted_network"><a class="viewcode-back" href="../../api.html#PopPUNK.network.construct_dense_weighted_network">[docs]</a><span class="k">def</span> <span class="nf">construct_dense_weighted_network</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">distMat</span><span class="p">,</span> <span class="n">weights_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct an undirected network using sequence lists, assignments of pairwise distances</span>
<span class="sd">    to clusters, and the identifier of the cluster assigned to within-strain distances.</span>
<span class="sd">    Nodes are samples and edges where samples are within the same cluster</span>

<span class="sd">    Will print summary statistics about the network to ``STDERR``</span>

<span class="sd">    Args:</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            List of reference sequence labels</span>
<span class="sd">        distMat (2 column ndarray)</span>
<span class="sd">            Numpy array of pairwise distances</span>
<span class="sd">        weights_type (str)</span>
<span class="sd">            Type of weight to use for network</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The resulting network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># data structures</span>
    <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">rlist</span>

    <span class="c1"># Filter weights to only the relevant edges</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Need weights to construct weighted network</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Process weights</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">process_weights</span><span class="p">(</span><span class="n">distMat</span><span class="p">,</span> <span class="n">weights_type</span><span class="p">)</span>

    <span class="c1"># Convert edge indices to tuples</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="n">poppunk_refine</span><span class="o">.</span><span class="n">generateAllTuples</span><span class="p">(</span><span class="n">num_ref</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rlist</span><span class="p">),</span>
                                                <span class="bp">self</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                <span class="n">int_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="c1"># Construct network with GPU via data frame</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">])</span>
        <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="n">max_in_vertex_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">add_self_loop</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">max_in_vertex_labels</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Construct network with CPU via edge list</span>
        <span class="n">weighted_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">),</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="n">weighted_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="c1"># build the graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">directed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">))</span>
        <span class="n">eweight</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="c1"># Could alternatively assign weights through eweight.a = weights</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">weighted_edges</span><span class="p">,</span> <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">eweight</span><span class="p">])</span>
        <span class="n">G</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eweight</span>

    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="construct_network_from_assignments"><a class="viewcode-back" href="../../api.html#PopPUNK.network.construct_network_from_assignments">[docs]</a><span class="k">def</span> <span class="nf">construct_network_from_assignments</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">within_label</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">int_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">distMat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weights_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">previous_network</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">old_ids</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">previous_pkl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample_default</span><span class="p">,</span>
    <span class="n">summarise</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct an undirected network using sequence lists, assignments of pairwise distances</span>
<span class="sd">    to clusters, and the identifier of the cluster assigned to within-strain distances.</span>
<span class="sd">    Nodes are samples and edges where samples are within the same cluster</span>

<span class="sd">    Will print summary statistics about the network to ``STDERR``</span>

<span class="sd">    Args:</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            List of reference sequence labels</span>
<span class="sd">        qlist (list)</span>
<span class="sd">            List of query sequence labels</span>
<span class="sd">        assignments (numpy.array or int)</span>
<span class="sd">            Labels of most likely cluster assignment</span>
<span class="sd">        within_label (int)</span>
<span class="sd">            The label for the cluster representing within-strain distances</span>
<span class="sd">        int_offset (int)</span>
<span class="sd">            Constant integer to add to each node index</span>
<span class="sd">        weights (list)</span>
<span class="sd">            List of weights for each edge in the network</span>
<span class="sd">        distMat (2 column ndarray)</span>
<span class="sd">            Numpy array of pairwise distances</span>
<span class="sd">        weights_type (str)</span>
<span class="sd">            Measure to calculate from the distMat to use as edge weights in network</span>
<span class="sd">            - options are core, accessory or euclidean distance</span>
<span class="sd">        previous_network (str)</span>
<span class="sd">            Name of file containing a previous network to be integrated into this new</span>
<span class="sd">            network</span>
<span class="sd">        old_ids (list)</span>
<span class="sd">            Ordered list of vertex names in previous network</span>
<span class="sd">        adding_qq_dists (bool)</span>
<span class="sd">            Boolean specifying whether query-query edges are being added</span>
<span class="sd">            to an existing network, such that not all the sequence IDs will</span>
<span class="sd">            be found in the old IDs, which should already be correctly ordered</span>
<span class="sd">        previous_pkl (str)</span>
<span class="sd">            Name of file containing the names of the sequences in the previous_network</span>
<span class="sd">        betweenness_sample (int)</span>
<span class="sd">            Number of sequences per component used to estimate betweenness using</span>
<span class="sd">            a GPU. Smaller numbers are faster but less precise [default = 100]</span>
<span class="sd">        summarise (bool)</span>
<span class="sd">            Whether to calculate and print network summaries with :func:`~networkSummary`</span>
<span class="sd">            (default = True)</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use GPUs for network construction</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The resulting network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Filter weights to only the relevant edges</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">assignments</span> <span class="o">==</span> <span class="n">within_label</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">distMat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">assignments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">assignments</span><span class="p">)</span>
        <span class="n">distMat</span> <span class="o">=</span> <span class="n">distMat</span><span class="p">[</span><span class="n">assignments</span> <span class="o">==</span> <span class="n">within_label</span><span class="p">,:]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">process_weights</span><span class="p">(</span><span class="n">distMat</span><span class="p">,</span> <span class="n">weights_type</span><span class="p">)</span>

    <span class="c1"># Convert edge indices to tuples</span>
    <span class="n">connections</span> <span class="o">=</span> <span class="n">poppunk_refine</span><span class="o">.</span><span class="n">generateTuples</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span>
                                                <span class="n">within_label</span><span class="p">,</span>
                                                <span class="bp">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">rlist</span> <span class="o">==</span> <span class="n">qlist</span><span class="p">),</span>
                                                <span class="n">num_ref</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rlist</span><span class="p">),</span>
                                                <span class="n">int_offset</span> <span class="o">=</span> <span class="n">int_offset</span><span class="p">)</span>

    <span class="c1"># Construct network using edge list</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_edge_list</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">connections</span><span class="p">,</span>
                                            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">,</span>
                                            <span class="n">distMat</span> <span class="o">=</span> <span class="n">distMat</span><span class="p">,</span>
                                            <span class="n">previous_network</span> <span class="o">=</span> <span class="n">previous_network</span><span class="p">,</span>
                                            <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="n">adding_qq_dists</span><span class="p">,</span>
                                            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">old_ids</span><span class="p">,</span>
                                            <span class="n">previous_pkl</span> <span class="o">=</span> <span class="n">previous_pkl</span><span class="p">,</span>
                                            <span class="n">summarise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">summarise</span><span class="p">:</span>
        <span class="n">print_network_summary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="get_cugraph_triangles"><a class="viewcode-back" href="../../api.html#PopPUNK.network.get_cugraph_triangles">[docs]</a><span class="k">def</span> <span class="nf">get_cugraph_triangles</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Counts the number of triangles in a cugraph</span>
<span class="sd">    network. Can be removed when the cugraph issue</span>
<span class="sd">    https://github.com/rapidsai/cugraph/issues/1043 is fixed.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (cugraph network)</span>
<span class="sd">            Network to be analysed</span>

<span class="sd">    Returns:</span>
<span class="sd">        triangle_count (int)</span>
<span class="sd">            Count of triangles in graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nlen</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">view_edge_list</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nlen</span><span class="p">,</span> <span class="n">nlen</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">dst</span><span class="o">.</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="p">)</span>
    <span class="n">triangle_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)))</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">triangle_count</span></div>

<div class="viewcode-block" id="networkSummary"><a class="viewcode-back" href="../../api.html#PopPUNK.network.networkSummary">[docs]</a><span class="k">def</span> <span class="nf">networkSummary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">calc_betweenness</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">betweenness_sample</span> <span class="o">=</span> <span class="n">betweenness_sample_default</span><span class="p">,</span>
                    <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides summary values about the network</span>

<span class="sd">    Args:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            The network of strains</span>
<span class="sd">        calc_betweenness (bool)</span>
<span class="sd">            Whether to calculate betweenness stats</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use cugraph for graph analysis</span>

<span class="sd">    Returns:</span>
<span class="sd">        metrics (list)</span>
<span class="sd">            List with # components, density, transitivity, mean betweenness</span>
<span class="sd">            and weighted mean betweenness</span>
<span class="sd">        scores (list)</span>
<span class="sd">            List of scores</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">component_assignments</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">component_nums</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_nums</span><span class="p">)</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># consistent with graph-tool for small graphs - triangle counts differ for large graphs</span>
        <span class="c1"># could reflect issue https://github.com/rapidsai/cugraph/issues/1043</span>
        <span class="c1"># this command can be restored once the above issue is fixed - scheduled for cugraph 0.20</span>
<span class="c1">#        triangle_count = cugraph.community.triangle_count.triangles(G)/3</span>
        <span class="n">triangle_count</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">get_cugraph_triangles</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">degree_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span>
        <span class="c1"># consistent with graph-tool</span>
        <span class="n">triad_count</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">degree_df</span><span class="p">[</span><span class="n">degree_df</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">triad_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">transitivity</span> <span class="o">=</span> <span class="n">triangle_count</span><span class="o">/</span><span class="n">triad_count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transitivity</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">component_assignments</span><span class="p">,</span> <span class="n">component_frequencies</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_frequencies</span><span class="p">)</span>
        <span class="n">density</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">/</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">transitivity</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">global_clustering</span><span class="p">(</span><span class="n">G</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">mean_bt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">weighted_mean_bt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">calc_betweenness</span><span class="p">:</span>
        <span class="n">betweenness</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
            <span class="n">component_frequencies</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sort</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">component_nums</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">():</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">component_frequencies</span><span class="p">[</span><span class="n">component_frequencies</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">component</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">component_vertices</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">][</span><span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">component</span><span class="p">]</span>
                    <span class="n">subgraph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">component_vertices</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_vertices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">betweenness_sample</span><span class="p">:</span>
                        <span class="n">component_betweenness</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">subgraph</span><span class="p">,</span>
                                                                                <span class="n">k</span> <span class="o">=</span> <span class="n">betweenness_sample</span><span class="p">,</span>
                                                                                <span class="n">normalized</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">component_betweenness</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">subgraph</span><span class="p">,</span>
                                                                                <span class="n">normalized</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">betweenness</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component_betweenness</span><span class="p">[</span><span class="s1">&#39;betweenness_centrality&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                    <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">component_frequencies</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">vfilt</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">component</span>
                    <span class="n">subgraph</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">vfilt</span><span class="p">)</span>
                    <span class="n">betweenness</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">vertex_betweenness</span><span class="p">(</span><span class="n">subgraph</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
                    <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betweenness</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mean_bt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">betweenness</span><span class="p">)</span>
            <span class="n">weighted_mean_bt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">betweenness</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">sizes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">betweenness</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mean_bt</span> <span class="o">=</span> <span class="n">betweenness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">weighted_mean_bt</span> <span class="o">=</span> <span class="n">betweenness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate scores</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">components</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">transitivity</span><span class="p">,</span> <span class="n">mean_bt</span><span class="p">,</span> <span class="n">weighted_mean_bt</span><span class="p">]</span>
    <span class="n">base_score</span> <span class="o">=</span> <span class="n">transitivity</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">density</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">base_score</span><span class="p">,</span> <span class="n">base_score</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">metrics</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">base_score</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">metrics</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span></div>

<span class="c1"># graph-tool only, for now</span>
<div class="viewcode-block" id="vertex_betweenness"><a class="viewcode-back" href="../../api.html#PopPUNK.network.vertex_betweenness">[docs]</a><span class="k">def</span> <span class="nf">vertex_betweenness</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns betweenness for nodes in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gt</span><span class="o">.</span><span class="n">betweenness</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span></div>

<div class="viewcode-block" id="addQueryToNetwork"><a class="viewcode-back" href="../../api.html#PopPUNK.network.addQueryToNetwork">[docs]</a><span class="k">def</span> <span class="nf">addQueryToNetwork</span><span class="p">(</span><span class="n">dbFuncs</span><span class="p">,</span> <span class="n">rList</span><span class="p">,</span> <span class="n">qList</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span>
                      <span class="n">assignments</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">queryDB</span><span class="p">,</span> <span class="n">kmers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">distance_type</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
                      <span class="n">queryQuery</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">strand_preserved</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds edges between queries and items in the reference database,</span>
<span class="sd">    and modifies the network to include them.</span>

<span class="sd">    Args:</span>
<span class="sd">        dbFuncs (list)</span>
<span class="sd">            List of backend functions from :func:`~PopPUNK.utils.setupDBFuncs`</span>
<span class="sd">        rList (list)</span>
<span class="sd">            List of reference names</span>
<span class="sd">        qList (list)</span>
<span class="sd">            List of query names</span>
<span class="sd">        G (graph)</span>
<span class="sd">            Network to add to (mutated)</span>
<span class="sd">        assignments (numpy.array)</span>
<span class="sd">            Cluster assignment of items in qlist</span>
<span class="sd">        model (ClusterModel)</span>
<span class="sd">            Model fitted to reference database</span>
<span class="sd">        queryDB (str)</span>
<span class="sd">            Query database location</span>
<span class="sd">        distances (str)</span>
<span class="sd">            Prefix of distance files for extending network</span>
<span class="sd">        kmers (list)</span>
<span class="sd">            List of k-mer sizes</span>
<span class="sd">        distance_type (str)</span>
<span class="sd">            Distance type to use as weights in network</span>
<span class="sd">        queryQuery (bool)</span>
<span class="sd">            Add in all query-query distances</span>
<span class="sd">            (default = False)</span>
<span class="sd">        strand_preserved (bool)</span>
<span class="sd">            Whether to treat strand as known (i.e. ignore rc k-mers)</span>
<span class="sd">            when adding random distances. Only used if queryQuery = True</span>
<span class="sd">            [default = False]</span>
<span class="sd">        weights (numpy.array)</span>
<span class="sd">            If passed, the core,accessory distances for each assignment, which will</span>
<span class="sd">            be annotated as an edge attribute</span>
<span class="sd">        threads (int)</span>
<span class="sd">            Number of threads to use if new db created</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use cugraph for analysis</span>

<span class="sd">            (default = 1)</span>
<span class="sd">    Returns:</span>
<span class="sd">        distMat (numpy.array)</span>
<span class="sd">            Query-query distances</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initalise functions</span>
    <span class="n">queryDatabase</span> <span class="o">=</span> <span class="n">dbFuncs</span><span class="p">[</span><span class="s1">&#39;queryDatabase&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kmers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Must provide db querying info (kmers) if adding &quot;</span>
                           <span class="s2">&quot;more than one sample, as q-q dists may be needed&quot;</span><span class="p">)</span>

    <span class="c1"># do not calculate weights unless specified</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weights_type</span> <span class="o">=</span> <span class="n">distance_type</span>

    <span class="c1"># These are returned</span>
    <span class="n">qqDistMat</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># store links for each query in a list of edge tuples</span>
    <span class="n">ref_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rList</span><span class="p">)</span>

    <span class="c1"># Add queries to network</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_assignments</span><span class="p">(</span><span class="n">rList</span><span class="p">,</span>
                                            <span class="n">qList</span><span class="p">,</span>
                                            <span class="n">assignments</span><span class="p">,</span>
                                            <span class="n">within_label</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">within_label</span><span class="p">,</span>
                                            <span class="n">previous_network</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
                                            <span class="n">old_ids</span> <span class="o">=</span> <span class="n">rList</span><span class="p">,</span>
                                            <span class="n">distMat</span> <span class="o">=</span> <span class="n">weights</span><span class="p">,</span>
                                            <span class="n">weights_type</span> <span class="o">=</span> <span class="n">weights_type</span><span class="p">,</span>
                                            <span class="n">summarise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>

    <span class="c1"># Check if any queries were not assigned, run qq dists if so</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">queryQuery</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
            <span class="n">edge_count</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ref_count</span><span class="p">,</span> <span class="n">ref_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">qList</span><span class="p">))))</span>
            <span class="n">new_query_clusters</span> <span class="o">=</span> <span class="n">edge_count</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_count</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_total_degrees</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ref_count</span><span class="p">,</span> <span class="n">ref_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">qList</span><span class="p">))))</span>
            <span class="n">new_query_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">edge_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_query_clusters</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Found novel query clusters. Calculating distances between them.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">queryQuery</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Calculate all query-query distances too, if updating database</span>
    <span class="k">if</span> <span class="n">queryQuery</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">qqDistMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Calculating all query-query distances</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">addRandom</span><span class="p">(</span><span class="n">queryDB</span><span class="p">,</span> <span class="n">qList</span><span class="p">,</span> <span class="n">kmers</span><span class="p">,</span> <span class="n">strand_preserved</span><span class="p">,</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span><span class="p">)</span>
            <span class="n">qqDistMat</span> <span class="o">=</span> <span class="n">queryDatabase</span><span class="p">(</span><span class="n">rNames</span> <span class="o">=</span> <span class="n">qList</span><span class="p">,</span>
                                      <span class="n">qNames</span> <span class="o">=</span> <span class="n">qList</span><span class="p">,</span>
                                      <span class="n">dbPrefix</span> <span class="o">=</span> <span class="n">queryDB</span><span class="p">,</span>
                                      <span class="n">queryPrefix</span> <span class="o">=</span> <span class="n">queryDB</span><span class="p">,</span>
                                      <span class="n">klist</span> <span class="o">=</span> <span class="n">kmers</span><span class="p">,</span>
                                      <span class="bp">self</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="n">number_plot_fits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                      <span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;core&#39;</span><span class="p">:</span>
                <span class="n">queryAssignation</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">qqDistMat</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;accessory&#39;</span><span class="p">:</span>
                <span class="n">queryAssignation</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">qqDistMat</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">queryAssignation</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">qqDistMat</span><span class="p">)</span>

            <span class="c1"># Add queries to network</span>
            <span class="n">vertex_labels</span> <span class="o">=</span> <span class="n">rList</span> <span class="o">+</span> <span class="n">qList</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_assignments</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">,</span>
                                                   <span class="n">vertex_labels</span><span class="p">,</span>
                                                    <span class="n">queryAssignation</span><span class="p">,</span>
                                                    <span class="n">int_offset</span> <span class="o">=</span> <span class="n">ref_count</span><span class="p">,</span>
                                                    <span class="n">within_label</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">within_label</span><span class="p">,</span>
                                                    <span class="n">previous_network</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
                                                    <span class="n">old_ids</span> <span class="o">=</span> <span class="n">vertex_labels</span><span class="p">,</span>
                                                    <span class="n">adding_qq_dists</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">distMat</span> <span class="o">=</span> <span class="n">qqDistMat</span><span class="p">,</span>
                                                    <span class="n">weights_type</span> <span class="o">=</span> <span class="n">weights_type</span><span class="p">,</span>
                                                    <span class="n">summarise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">qqDistMat</span></div>

<div class="viewcode-block" id="add_self_loop"><a class="viewcode-back" href="../../api.html#PopPUNK.network.add_self_loop">[docs]</a><span class="k">def</span> <span class="nf">add_self_loop</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds self-loop to cugraph graph to ensure all nodes are included in</span>
<span class="sd">    the graph, even if singletons.</span>

<span class="sd">    Args:</span>
<span class="sd">        G_df (cudf)</span>
<span class="sd">            cudf data frame containing edge list</span>
<span class="sd">        seq_num (int)</span>
<span class="sd">            The expected number of nodes in the graph</span>
<span class="sd">        renumber (bool)</span>
<span class="sd">            Whether to renumber the vertices when added to the graph</span>

<span class="sd">    Returns:</span>
<span class="sd">        G_new (graph)</span>
<span class="sd">            Dictionary of cluster assignments (keys are sequence names)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use self-loop to ensure all nodes are present</span>
    <span class="n">min_in_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()])</span>
    <span class="k">if</span> <span class="n">min_in_df</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">G_self_loop</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">G_self_loop</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G_self_loop</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">G_self_loop</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">G_df</span><span class="p">,</span><span class="n">G_self_loop</span><span class="p">],</span> <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">max_in_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
    <span class="k">if</span> <span class="n">max_in_df</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">!=</span> <span class="n">seq_num</span><span class="p">:</span>
        <span class="n">G_self_loop</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">G_self_loop</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">seq_num</span><span class="p">]</span>
        <span class="n">G_self_loop</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">seq_num</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">G_self_loop</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">G_df</span><span class="p">,</span><span class="n">G_self_loop</span><span class="p">],</span> <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Construct graph</span>
    <span class="n">G_new</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">G_new</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">edge_attr</span> <span class="o">=</span> <span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="n">renumber</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_new</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="n">renumber</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_new</span></div>


<div class="viewcode-block" id="printClusters"><a class="viewcode-back" href="../../api.html#PopPUNK.network.printClusters">[docs]</a><span class="k">def</span> <span class="nf">printClusters</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rlist</span><span class="p">,</span> <span class="n">outPrefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oldClusterFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">externalClusterCSV</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">printRef</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">printCSV</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">clustering_type</span><span class="o">=</span><span class="s1">&#39;combined&#39;</span><span class="p">,</span> <span class="n">write_unwords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get cluster assignments</span>

<span class="sd">    Also writes assignments to a CSV file</span>

<span class="sd">    Args:</span>
<span class="sd">        G (graph)</span>
<span class="sd">            Network used to define clusters</span>
<span class="sd">        rlist (list)</span>
<span class="sd">            Names of samples</span>
<span class="sd">        outPrefix (str)</span>
<span class="sd">            Prefix for output CSV</span>
<span class="sd">            Default = None</span>
<span class="sd">        oldClusterFile (str)</span>
<span class="sd">            CSV with previous cluster assignments.</span>
<span class="sd">            Pass to ensure consistency in cluster assignment name.</span>
<span class="sd">            Default = None</span>
<span class="sd">        externalClusterCSV (str)</span>
<span class="sd">            CSV with cluster assignments from any source. Will print a file</span>
<span class="sd">            relating these to new cluster assignments</span>
<span class="sd">            Default = None</span>
<span class="sd">        printRef (bool)</span>
<span class="sd">            If false, print only query sequences in the output</span>
<span class="sd">            Default = True</span>
<span class="sd">        printCSV (bool)</span>
<span class="sd">            Print results to file</span>
<span class="sd">            Default = True</span>
<span class="sd">        clustering_type (str)</span>
<span class="sd">            Type of clustering network, used for comparison with old clusters</span>
<span class="sd">            Default = &#39;combined&#39;</span>
<span class="sd">        write_unwords (bool)</span>
<span class="sd">            Write clusters with a pronouncable name rather than numerical index</span>
<span class="sd">            Default = True</span>
<span class="sd">        use_gpu (bool)</span>
<span class="sd">            Whether to use cugraph for network analysis</span>
<span class="sd">    Returns:</span>
<span class="sd">        clustering (dict)</span>
<span class="sd">            Dictionary of cluster assignments (keys are sequence names)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">oldClusterFile</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">printRef</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Trying to print query clusters with no query sequences&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">write_unwords</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">printCSV</span><span class="p">:</span>
        <span class="n">write_unwords</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># get a sorted list of component assignments</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">component_assignments</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">component_frequencies</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sort</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">newClusters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">component_frequencies</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">isolate_index</span><span class="p">,</span> <span class="n">isolate_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rlist</span><span class="p">):</span> <span class="c1"># assume sorted at the moment</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">isolate_index</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">component_rank_bool</span> <span class="o">=</span> <span class="n">component_frequencies</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">component</span>
            <span class="n">component_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">component_rank_bool</span><span class="p">))</span>
            <span class="n">newClusters</span><span class="p">[</span><span class="n">component_rank</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">isolate_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">component_assignments</span><span class="p">,</span> <span class="n">component_frequencies</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">component_frequency_ranks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_frequencies</span><span class="p">)</span> <span class="o">-</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">component_frequencies</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># use components to determine new clusters</span>
        <span class="n">newClusters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component_frequency_ranks</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">isolate_index</span><span class="p">,</span> <span class="n">isolate_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rlist</span><span class="p">):</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">isolate_index</span><span class="p">]</span>
            <span class="n">component_rank</span> <span class="o">=</span> <span class="n">component_frequency_ranks</span><span class="p">[</span><span class="n">component</span><span class="p">]</span>
            <span class="n">newClusters</span><span class="p">[</span><span class="n">component_rank</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">isolate_name</span><span class="p">)</span>

    <span class="n">oldNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">oldClusterFile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">oldAllClusters</span> <span class="o">=</span> <span class="n">readIsolateTypeFromCsv</span><span class="p">(</span><span class="n">oldClusterFile</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;external&#39;</span><span class="p">,</span> <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">oldClusters</span> <span class="o">=</span> <span class="n">oldAllClusters</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">oldAllClusters</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">new_id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldClusters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 1-indexed</span>
        <span class="k">while</span> <span class="n">new_id</span> <span class="ow">in</span> <span class="n">oldClusters</span><span class="p">:</span>
            <span class="n">new_id</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># in case clusters have been merged</span>

        <span class="c1"># Samples in previous clustering</span>
        <span class="k">for</span> <span class="n">prev_cluster</span> <span class="ow">in</span> <span class="n">oldClusters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">prev_sample</span> <span class="ow">in</span> <span class="n">prev_cluster</span><span class="p">:</span>
                <span class="n">oldNames</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prev_sample</span><span class="p">)</span>

    <span class="c1"># Assign each cluster a name</span>
    <span class="n">clustering</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">foundOldClusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cluster_unword</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">write_unwords</span><span class="p">:</span>
        <span class="n">unword_generator</span> <span class="o">=</span> <span class="n">gen_unword</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">newClsIdx</span><span class="p">,</span> <span class="n">newCluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">newClusters</span><span class="p">):</span>
        <span class="n">needs_unword</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Ensure consistency with previous labelling</span>
        <span class="k">if</span> <span class="n">oldClusterFile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">merge</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cls_id</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Samples in this cluster that are not queries</span>
            <span class="n">ref_only</span> <span class="o">=</span> <span class="n">oldNames</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">newCluster</span><span class="p">)</span>

            <span class="c1"># A cluster with no previous observations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_only</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cls_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_id</span><span class="p">)</span>    <span class="c1"># harmonise data types; string flexibility helpful</span>
                <span class="n">new_id</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">needs_unword</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Search through old cluster IDs to find a match</span>
                <span class="k">for</span> <span class="n">oldClusterName</span><span class="p">,</span> <span class="n">oldClusterMembers</span> <span class="ow">in</span> <span class="n">oldClusters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">join</span> <span class="o">=</span> <span class="n">ref_only</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">oldClusterMembers</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">join</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Check cluster is consistent with previous definitions</span>
                        <span class="k">if</span> <span class="n">oldClusterName</span> <span class="ow">in</span> <span class="n">foundOldClusters</span><span class="p">:</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;WARNING: Old cluster &quot;</span> <span class="o">+</span> <span class="n">oldClusterName</span> <span class="o">+</span> <span class="s2">&quot; split&quot;</span>
                                             <span class="s2">&quot; across multiple new clusters</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">foundOldClusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oldClusterName</span><span class="p">)</span>

                        <span class="c1"># Query has merged clusters</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">join</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_only</span><span class="p">):</span>
                            <span class="n">merge</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">needs_unword</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="n">cls_id</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">cls_id</span> <span class="o">=</span> <span class="n">oldClusterName</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">cls_id</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">oldClusterName</span>
                        <span class="c1"># Exact match -&gt; same name as before</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">join</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_only</span><span class="p">):</span>
                            <span class="k">assert</span> <span class="n">merge</span> <span class="o">==</span> <span class="kc">False</span> <span class="c1"># should not have already been part of a merge</span>
                            <span class="n">cls_id</span> <span class="o">=</span> <span class="n">oldClusterName</span>
                            <span class="k">break</span>

            <span class="c1"># Report merges</span>
            <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>
                <span class="n">merged_ids</span> <span class="o">=</span> <span class="n">cls_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Clusters &quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">merged_ids</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; have merged into &quot;</span> <span class="o">+</span> <span class="n">cls_id</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Otherwise just number sequentially starting from 1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cls_id</span> <span class="o">=</span> <span class="n">newClsIdx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">needs_unword</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">write_unwords</span> <span class="ow">and</span> <span class="n">needs_unword</span><span class="p">:</span>
            <span class="n">unword</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">unword_generator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unword</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">cluster_member</span> <span class="ow">in</span> <span class="n">newCluster</span><span class="p">:</span>
            <span class="n">clustering</span><span class="p">[</span><span class="n">cluster_member</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_id</span>
            <span class="k">if</span> <span class="n">unword</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cluster_unword</span><span class="p">[</span><span class="n">cluster_member</span><span class="p">]</span> <span class="o">=</span> <span class="n">unword</span>

    <span class="c1"># print clustering to file</span>
    <span class="k">if</span> <span class="n">printCSV</span><span class="p">:</span>
        <span class="n">outFileName</span> <span class="o">=</span> <span class="n">outPrefix</span> <span class="o">+</span> <span class="s2">&quot;_clusters.csv&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outFileName</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cluster_file</span><span class="p">:</span>
            <span class="n">cluster_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Taxon,Cluster</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">write_unwords</span><span class="p">:</span>
                <span class="n">unword_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outPrefix</span> <span class="o">+</span> <span class="s2">&quot;_unword_clusters.csv&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="n">unword_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Taxon,Cluster_name</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># sort the clusters by frequency - define a list with a custom sort order</span>
            <span class="c1"># first line gives tuples e.g. (1, 28), (2, 17) - cluster 1 has 28 members, cluster 2 has 17 members</span>
            <span class="c1"># second line takes first element - the cluster IDs sorted by frequency</span>
            <span class="n">freq_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">clustering</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">freq_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">freq_order</span><span class="p">]</span>

            <span class="c1"># iterate through cluster dictionary sorting by value using above custom sort order</span>
            <span class="k">for</span> <span class="n">cluster_member</span><span class="p">,</span> <span class="n">cluster_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">clustering</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">freq_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">printRef</span> <span class="ow">or</span> <span class="n">cluster_member</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">oldNames</span><span class="p">:</span>
                    <span class="n">cluster_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">cluster_member</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_name</span><span class="p">)))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">write_unwords</span> <span class="ow">and</span> <span class="n">cluster_member</span> <span class="ow">in</span> <span class="n">cluster_unword</span><span class="p">:</span>
                    <span class="n">unword_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">cluster_member</span><span class="p">,</span> <span class="n">cluster_unword</span><span class="p">[</span><span class="n">cluster_member</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">write_unwords</span><span class="p">:</span>
                <span class="n">unword_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">externalClusterCSV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">printExternalClusters</span><span class="p">(</span><span class="n">newClusters</span><span class="p">,</span> <span class="n">externalClusterCSV</span><span class="p">,</span> <span class="n">outPrefix</span><span class="p">,</span> <span class="n">oldNames</span><span class="p">,</span> <span class="n">printRef</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">clustering</span><span class="p">)</span></div>

<div class="viewcode-block" id="printExternalClusters"><a class="viewcode-back" href="../../api.html#PopPUNK.network.printExternalClusters">[docs]</a><span class="k">def</span> <span class="nf">printExternalClusters</span><span class="p">(</span><span class="n">newClusters</span><span class="p">,</span> <span class="n">extClusterFile</span><span class="p">,</span> <span class="n">outPrefix</span><span class="p">,</span>
                          <span class="n">oldNames</span><span class="p">,</span> <span class="n">printRef</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prints cluster assignments with respect to previously defined</span>
<span class="sd">    clusters or labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        newClusters (set iterable)</span>
<span class="sd">            The components from the graph G, defining the PopPUNK clusters</span>
<span class="sd">        extClusterFile (str)</span>
<span class="sd">            A CSV file containing definitions of the external clusters for</span>
<span class="sd">            each sample (does not need to contain all samples)</span>
<span class="sd">        outPrefix (str)</span>
<span class="sd">            Prefix for output CSV (_external_clusters.csv)</span>
<span class="sd">        oldNames (list)</span>
<span class="sd">            A list of the reference sequences</span>
<span class="sd">        printRef (bool)</span>
<span class="sd">            If false, print only query sequences in the output</span>

<span class="sd">            Default = True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Object to store output csv datatable</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="c1"># Read in external clusters</span>
    <span class="n">extClusters</span> <span class="o">=</span> \
        <span class="n">readIsolateTypeFromCsv</span><span class="p">(</span><span class="n">extClusterFile</span><span class="p">,</span>
                               <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;external&#39;</span><span class="p">,</span>
                               <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Go through each cluster (as defined by poppunk) and find the external</span>
    <span class="c1"># clusters that had previously been assigned to any sample in the cluster</span>
    <span class="k">for</span> <span class="n">ppCluster</span> <span class="ow">in</span> <span class="n">newClusters</span><span class="p">:</span>
        <span class="c1"># Store clusters as a set to avoid duplicates</span>
        <span class="n">prevClusters</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">ppCluster</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">extCluster</span> <span class="ow">in</span> <span class="n">extClusters</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">extClusters</span><span class="p">[</span><span class="n">extCluster</span><span class="p">]:</span>
                    <span class="n">prevClusters</span><span class="p">[</span><span class="n">extCluster</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">extClusters</span><span class="p">[</span><span class="n">extCluster</span><span class="p">][</span><span class="n">sample</span><span class="p">])</span>

        <span class="c1"># Go back through and print the samples that were found</span>
        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">ppCluster</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">printRef</span> <span class="ow">or</span> <span class="n">sample</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">oldNames</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">extCluster</span> <span class="ow">in</span> <span class="n">extClusters</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">extCluster</span> <span class="ow">in</span> <span class="n">prevClusters</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">extCluster</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prevClusters</span><span class="p">[</span><span class="n">extCluster</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">extCluster</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;NA&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;sample&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;WARNING: No new samples found, cannot write external clusters</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outPrefix</span> <span class="o">+</span> <span class="s2">&quot;_external_clusters.csv&quot;</span><span class="p">,</span>
                                    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sample&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">extClusters</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                    <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="generate_minimum_spanning_tree"><a class="viewcode-back" href="../../api.html#PopPUNK.network.generate_minimum_spanning_tree">[docs]</a><span class="k">def</span> <span class="nf">generate_minimum_spanning_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">from_cugraph</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a minimum spanning tree from a network</span>

<span class="sd">    Args:</span>
<span class="sd">       G (network)</span>
<span class="sd">           Graph tool network</span>
<span class="sd">       from_cugraph (bool)</span>
<span class="sd">            If a pre-calculated MST from cugraph</span>
<span class="sd">            [default = False]</span>

<span class="sd">    Returns:</span>
<span class="sd">       mst_network (str)</span>
<span class="sd">           Minimum spanning tree (as graph-tool graph)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># Create MST</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">from_cugraph</span><span class="p">:</span>
        <span class="n">mst_network</span> <span class="o">=</span> <span class="n">G</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Starting calculation of minimum-spanning tree</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Test if weighted network and calculate minimum spanning tree</span>
        <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">:</span>
            <span class="n">mst_edge_prop_map</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">])</span>
            <span class="n">mst_network</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">efilt</span> <span class="o">=</span> <span class="n">mst_edge_prop_map</span><span class="p">)</span>
            <span class="n">mst_network</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">mst_network</span><span class="p">,</span> <span class="n">prune</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;generate_minimum_spanning_tree requires a weighted graph</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;MST passed unweighted graph&quot;</span><span class="p">)</span>

    <span class="c1"># Find seed nodes as those with greatest outdegree in each component</span>
    <span class="n">num_components</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">seed_vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">from_cugraph</span><span class="p">:</span>
        <span class="n">mst_df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">mst_network</span><span class="p">)</span>
        <span class="n">num_components_idx</span> <span class="o">=</span> <span class="n">mst_df</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">num_components</span> <span class="o">=</span> <span class="n">mst_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">num_components_idx</span><span class="p">][</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">num_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mst_df</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mst_network</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span>
            <span class="c1"># idxmax only returns first occurrence of maximum so should maintain</span>
            <span class="c1"># MST - check cuDF implementation is the same</span>
            <span class="n">max_indices</span> <span class="o">=</span> <span class="n">mst_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;labels&#39;</span><span class="p">])[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
            <span class="n">seed_vertices</span> <span class="o">=</span> <span class="n">mst_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">max_indices</span><span class="p">][</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">component_assignments</span><span class="p">,</span> <span class="n">component_frequencies</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_components</span><span class="p">(</span><span class="n">mst_network</span><span class="p">)</span>
        <span class="n">num_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_frequencies</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">component_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component_frequencies</span><span class="p">)):</span>
                <span class="n">component_members</span> <span class="o">=</span> <span class="n">component_assignments</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">component_index</span>
                <span class="n">component</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">mst_network</span><span class="p">,</span> <span class="n">vfilt</span> <span class="o">=</span> <span class="n">component_members</span><span class="p">)</span>
                <span class="n">component_vertices</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
                <span class="n">out_degrees</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">get_out_degrees</span><span class="p">(</span><span class="n">component_vertices</span><span class="p">)</span>
                <span class="n">seed_vertex</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">component_vertices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_degrees</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">out_degrees</span><span class="p">))])</span>
                <span class="n">seed_vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed_vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Can only add one otherwise not MST</span>


    <span class="c1"># If multiple components, add distances between seed nodes</span>
    <span class="k">if</span> <span class="n">num_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># Extract edges and maximum edge length - as DF for cugraph</span>
        <span class="c1"># list of tuples for graph-tool</span>
        <span class="k">if</span> <span class="n">from_cugraph</span><span class="p">:</span>
            <span class="c1"># With cugraph the MST is already calculated</span>
            <span class="c1"># so no extra edges can be retrieved from the graph</span>
            <span class="n">G_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">view_edge_list</span><span class="p">()</span>
            <span class="n">max_weight</span> <span class="o">=</span> <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">first_seed</span> <span class="o">=</span> <span class="n">seed_vertices</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">G_seed_link_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">G_seed_link_df</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed_vertices</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">seed_vertices</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">G_seed_link_df</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed_vertices</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">G_seed_link_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seed_vertices</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">G_df</span><span class="p">,</span><span class="n">G_seed_link_df</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># With graph-tool look to retrieve edges in larger graph</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">max_weight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">))</span>

            <span class="c1"># Identify edges between seeds to link components together</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">seed_vertices</span><span class="p">:</span>
                <span class="n">seed_edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_all_edges</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]])</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Not all edges may be in graph</span>
                <span class="k">for</span> <span class="n">seed_edge</span> <span class="ow">in</span> <span class="n">seed_edges</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">seed_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seed_vertices</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">seed_edge</span><span class="p">))</span>
                <span class="c1"># TODO: alternative would be to requery the DB (likely quick)</span>
                <span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">seed_vertices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">query</span> <span class="o">!=</span> <span class="n">ref</span><span class="p">:</span>
                            <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ref</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">))</span>

        <span class="c1"># Construct graph</span>
        <span class="k">if</span> <span class="n">from_cugraph</span><span class="p">:</span>
            <span class="n">mst_network</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
            <span class="n">G_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;dst&#39;</span><span class="p">:</span> <span class="s1">&#39;destination&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mst_network</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="n">renumber</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed_G</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">directed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">seed_G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seed_vertex</span><span class="p">))</span>
            <span class="n">eweight</span> <span class="o">=</span> <span class="n">seed_G</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="n">seed_G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">eweight</span><span class="p">])</span>
            <span class="n">seed_G</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eweight</span>
            <span class="n">seed_mst_edge_prop_map</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">seed_G</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">seed_G</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">])</span>
            <span class="n">seed_mst_network</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">seed_G</span><span class="p">,</span> <span class="n">efilt</span> <span class="o">=</span> <span class="n">seed_mst_edge_prop_map</span><span class="p">)</span>
            <span class="c1"># Insert seed MST into original MST - may be possible to use graph_union with include=True &amp; intersection</span>
            <span class="n">deep_edges</span> <span class="o">=</span> <span class="n">seed_mst_network</span><span class="o">.</span><span class="n">get_edges</span><span class="p">([</span><span class="n">seed_mst_network</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]])</span>
            <span class="n">mst_network</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">deep_edges</span><span class="p">)</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Completed calculation of minimum-spanning tree</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mst_network</span></div>

<div class="viewcode-block" id="get_vertex_list"><a class="viewcode-back" href="../../api.html#PopPUNK.network.get_vertex_list">[docs]</a><span class="k">def</span> <span class="nf">get_vertex_list</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a list of node indices</span>

<span class="sd">    Args:</span>
<span class="sd">       G (network)</span>
<span class="sd">           Graph tool network</span>
<span class="sd">       use_gpu (bool)</span>
<span class="sd">            Whether graph is a cugraph or not</span>
<span class="sd">            [default = False]</span>

<span class="sd">    Returns:</span>
<span class="sd">       vlist (list)</span>
<span class="sd">           List of integers corresponding to nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">vlist</span></div>

<div class="viewcode-block" id="save_network"><a class="viewcode-back" href="../../api.html#PopPUNK.network.save_network">[docs]</a><span class="k">def</span> <span class="nf">save_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_graphml</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save a network to disk</span>

<span class="sd">    Args:</span>
<span class="sd">       G (network)</span>
<span class="sd">           Graph tool network</span>
<span class="sd">       prefix (str)</span>
<span class="sd">           Prefix for output file</span>
<span class="sd">       use_graphml (bool)</span>
<span class="sd">           Whether to output a graph-tool file</span>
<span class="sd">           in graphml format</span>
<span class="sd">       use_gpu (bool)</span>
<span class="sd">           Whether graph is a cugraph or not</span>
<span class="sd">           [default = False]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="o">+</span> <span class="n">suffix</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">to_pandas_edgelist</span><span class="p">()</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.csv.gz&#39;</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">use_graphml</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.graphml&#39;</span><span class="p">,</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;graphml&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.gt&#39;</span><span class="p">,</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;gt&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="cugraph_to_graph_tool"><a class="viewcode-back" href="../../api.html#PopPUNK.network.cugraph_to_graph_tool">[docs]</a><span class="k">def</span> <span class="nf">cugraph_to_graph_tool</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save a network to disk</span>

<span class="sd">    Args:</span>
<span class="sd">       G (cugraph network)</span>
<span class="sd">         Cugraph network</span>
<span class="sd">       rlist (list)</span>
<span class="sd">         List of sequence names</span>

<span class="sd">    Returns:</span>
<span class="sd">      G (graph-tool network)</span>
<span class="sd">          Graph tool network</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">view_edge_list</span><span class="p">()</span>
    <span class="n">edge_tuple</span> <span class="o">=</span> <span class="n">edge_df</span><span class="p">[[</span><span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="s1">&#39;dst&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">edge_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">in</span> <span class="n">edge_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values_host</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_edge_list</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span> <span class="n">rlist</span><span class="p">,</span>
                                           <span class="n">edge_tuple</span><span class="p">,</span>
                                           <span class="n">weights</span> <span class="o">=</span> <span class="n">edge_weights</span><span class="p">,</span>
                                           <span class="n">summarise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">vid</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span>
                                <span class="n">vals</span> <span class="o">=</span> <span class="n">rlist</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">vid</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="sparse_mat_to_network"><a class="viewcode-back" href="../../api.html#PopPUNK.network.sparse_mat_to_network">[docs]</a><span class="k">def</span> <span class="nf">sparse_mat_to_network</span><span class="p">(</span><span class="n">sparse_mat</span><span class="p">,</span> <span class="n">rlist</span><span class="p">,</span> <span class="n">use_gpu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a network from a lineage rank fit</span>

<span class="sd">    Args:</span>
<span class="sd">       sparse_mat (scipy or cupyx sparse matrix)</span>
<span class="sd">         Sparse matrix of kNN from lineage fit</span>
<span class="sd">       rlist (list)</span>
<span class="sd">         List of sequence names</span>
<span class="sd">       use_gpu (bool)</span>
<span class="sd">         Whether GPU libraries should be used</span>

<span class="sd">    Returns:</span>
<span class="sd">      G (network)</span>
<span class="sd">          Graph tool or cugraph network</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">G_df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span><span class="s1">&#39;destination&#39;</span><span class="p">,</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span>
        <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="o">.</span><span class="n">row</span>
        <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="o">.</span><span class="n">col</span>
        <span class="n">G_df</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="o">.</span><span class="n">data</span>
        <span class="n">max_in_vertex_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rlist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">add_self_loop</span><span class="p">(</span><span class="n">G_df</span><span class="p">,</span> <span class="n">max_in_vertex_labels</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">renumber</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">dst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sparse_mat</span><span class="o">.</span><span class="n">row</span><span class="p">,</span><span class="n">sparse_mat</span><span class="o">.</span><span class="n">col</span><span class="p">):</span>
            <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">dst</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">construct_network_from_edge_list</span><span class="p">(</span><span class="n">rlist</span><span class="p">,</span>
                                               <span class="n">rlist</span><span class="p">,</span>
                                               <span class="n">connections</span><span class="p">,</span>
                                               <span class="n">weights</span><span class="o">=</span><span class="n">sparse_mat</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                               <span class="n">summarise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2018-2023, John Lees and Nicholas Croucher
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=1fc3131f"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>